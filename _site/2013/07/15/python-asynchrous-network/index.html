<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <meta charset="utf-8">
  <title>
    
      python asynchrous network &ndash;
    
    Hai
  </title>

  <meta name="author" content="Hai" />
  <meta name="description" content="A fantastic blog that is fantastic." />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <link rel="alternate" type="application/rss+xml" href="/atom.xml" />

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet" />
  <link rel="stylesheet" href="/css/base.css" type="text/css" media="screen, projection" />
  <link rel="stylesheet" href="/css/pygments.css" type="text/css" />
  <link media="only screen and (max-device-width: 480px)" href="/css/mobile.css" type="text/css" rel="stylesheet" />
  <link media="only screen and (device-width: 768px)" href="/css/mobile.css" type="text/css" rel="stylesheet" />
  <link href='http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz' rel='stylesheet' type='text/css'>
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />

  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
  <script type="text/javascript" src="/js/application.js"></script>
</head>

<body>
  <section class="sidebar">
    <a href="/">
      <img src="http://www.gravatar.com/avatar/60b5076bc49c5f6157687e39a34ad5cc?s=150" height="75" width="75" class="avatar" />
    </a>

    <section class="name">
      <a href="/">
        <span id="fname">Hai</span>
        <span id="lname">Hai</span>
      </a>
    </section>

    <section class="meta">
      <a href="https://github.com/" target="_blank"><i class="fa fa-github"></i></a>
      <a href="https://twitter.com/matrixorz" target="_blank"><i class="fa fa-twitter"></i></a>
      <a href="/atom.xml"><i class="fa fa-rss"></i></a>
    </section>

    <section class="sections">
      <ul>
        <li><a href="/about.html">about</a></li>
        <li><a href="/">posts</a></li>
      </ul>
    </section>
  </section>

  <section class="content">
  <h1>
    <a href="/2013/07/15/python-asynchrous-network">python asynchrous network</a>
  </h1>

  <section class="byline">
    July 15, 2013
  </section>

  <hr />

<h2>select,poll,epoll test in python</h2>

<p><strong><em>select test</em></strong> selecttest.py</p>

<pre><code>import select
import socket
import Queue

#create a socket
server=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
server.setblocking(False)
#set option reused
server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)

server_address=('localhost',10001)
server.bind(server_address)

server.listen(10)

#sockets from which we except to read
inputs=[server]

#sockets from which we expect to write
outputs=[]

#Outgoing message queues (socket:Queue)
message_queues={}

#A optional parameter for select is TIMEOUT
timeout=20

while inputs:
    print "waiting for next event"
    #first parameter--read list,second parameter--write list,third parameter--error list
    readable,writable,exceptional=select.select(inputs,outputs,inputs,timeout)

    #when timeout reached,select return three empty list
    if not (readable or writable or exceptional):
        print "Time out!"
        break;
    for s in readable:
        if s is server:
            #A "readable" socket is ready to accept a connection
            connection,client_address=s.accept()
            print "  connection from",client_address
            connection.setblocking(0)
            inputs.append(connection)
            message_queues[connection]=Queue.Queue()
        else:
            data=s.recv(1024)
            if data:
                print "received ",data, "from ",s.getpeername()
                message_queues[s].put(data)
                #Add output  channel for response
                if s not in outputs:
                    outputs.append(s)
            else:
                #Interpret empty result as closed connection
                print " closing", client_address
                if s in outputs:
                    outputs.remove(s)
                inputs.remove(s)
                s.close()
                #remove message queue
                del message_queues[s]
    for s in writable:
        try:
            next_msg=message_queues[s].get_nowait()
        except Queue.Empty:
            print " ",s.getpeername," queue empty"
            outputs.remove(s)
        else:
            print "sending ",next_msg," to",s.getpeername()
            s.send(next_msg)
    for s in exceptional:
        print " exception condition on ",s.getpeername()
        #stop listening for input on the connection
        inputs.remove(s)
        if s in outputs:
            outputs.remove(s)
        s.close()
        #Remove message queue
</code></pre>

<p><strong><em>polltest</em></strong> polltest.py</p>

<pre><code>import socket
import select
import Queue

server=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
server.setblocking(False)
server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
server_address=("localhost",10001)

print "Starting up on %s port %s" % server_address
server.bind(server_address)
server.listen(5)
message_queues={}
#The timeout value is represente in milliseconds,instead of seconds
timeout=100
#Create a limit for the next
READ_ONLY=(select.POLLIN | select.POLLPRI | select.POLLHUP | select.POLLERR)
READ_WRITE=(READ_ONLY|select.POLLOUT)

#set up the poller
poller=select.poll()
poller.register(server,READ_ONLY)
#map file descriptors to socket objects
fd_to_socket={server.fileno():server,}
while True:
    print "Waiting for the next event"
    events=poller.poll(timeout)
    print "*"*20
    print len(events)
    print events
    print "*"*20
    for fd,flag in events:
        s=fd_to_socket[fd]
        if flag &amp; (select.POLLIN|select.POLLPRI):
            if s is server:
                #A readable socket is ready to accept a connection
                connection,client_address=s.accept()
                print "Connection ",client_address
                connection.setblocking(False)

                fd_to_socket[connection.fileno()]=connection
                poller.register(connection,READ_ONLY)

                #Give the connection a queue to send data
                message_queues[connection]=Queue.Queue
            else:
                data=s.recv(1024)
                if data:
                    # A readable client socket has data
                    print " received %s from %s " % (data,s.getpeername())
                    message_queues[s].put(data)
                    poller.modify(s,READ_WRITE)
                else:
                    #Close the connection
                    print " closing ",s.getpeername()
                    #Stop listening for input on the connection
                    poller.unregister(s)
                    s.close()
                    del message_queues[s]
        elif flag &amp; select.POLLHUP:
            #A client that "Hang up",to be closed.
            print "closing ",s.getpeername,"(HUP)"
            poller.unregister(s)
            s.close()
        elif flag &amp; select.POLLOUT:
            #SOCKET is ready to send DATA,if there is any to send
            try:
                next_msg=message_queues[s].get_nowait()
            except Queue.Empty:
                #No messages waiting so stop checking
                print s.getpeername," queue empty"
                poller.modify(s,READ_ONLY)
            else:
                print " sending %s to %s" %(next_msg,s.getpeername())
                s.send(next_msg)
        elif flag &amp; select.POLLERR:
            #Any events with POLLER cause the server to close the sockets
            print " exception on",s.getpeername()
            poller.unregister(s)
            s.close()
            del message_queues[s]
</code></pre>

<p><strong><em>epoll test</em></strong> epolltest.py</p>

<pre><code>import socket,logging
import select,errno

logger=logging.getLogger("network-server")

def InitLog():
    logger.setLevel(logging.DEBUG)

    fh=logging.FileHandler("network-server.log")
    fh.setLevel(logging.DEBUG)
    ch=logging.StreamHandler()
    ch.setLevel(logging.DEBUG)

    formatter=logging.Formatter("%(asctime)s - %(name)s - %(levelname)s -%(message)s")
    ch.setFormatter(formatter)
    fh.setFormatter(formatter)

    logger.addHandler(fh)
    logger.addHandler(ch)

if __name__=="__main__":
    InitLog()

    try:
        listen_fd=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    except socket.error,msg:
        logger.error("create a socket failed")

    try:
        listen_fd.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
    except socket.error,msg:
        logger.error("setsocketopt error")

    try:
        listen_fd.bind(('',10001))
    except socket.error,msg:
        logger.error("listen file id bind ip error")

    try:
        listen_fd.listen(10)
    except socket.error,msg:
        logger.error(msg)
    try:
        epoll_fd=select.epoll()
        epoll_fd.register(listen_fd.fileno(),select.EPOLLIN)
    except select.error,msg:
        logger.error(msg)

    connections={}
    addresses={}
    datalist={}
    while True:
        epoll_list = epoll_fd.poll()
        for fd,events in epoll_list:
            if fd==listen_fd.fileno():
                conn,addr=listen_fd.accept()
                logger.debug("accept connction from  %s,%d,fd = %d" %(addr[0],addr[1],conn.fileno()))
                conn.setblocking(0)
                epoll_fd.register(conn.fileno(),select.EPOLLIN|select.EPOLLET)
                connections[conn.fileno()]=conn 
                addresses[conn.fileno()]=addr
            elif select.EPOLLIN  &amp; events:
                datas=''
                while True:
                    try:
                        data=connections[fd].recv(10)
                        if not data and not datas:
                            epoll_fd.unregister(fd)
                            connections[fd].close()
                            logger.debug("%s,%d closed" % (addresses[fd][0],addresses[fd][1]))

                            break
                        else:
                            datas+=data 
                    except socket.error,msg:
                        if msg.errno==errno.EAGAIN:
                            logger.debug("%s receive %s" % (fd,datas))
                            datalist[fd]=datas
                            epoll_fd.modify(fd,select.EPOLLET|select.EPOLLOUT)
                            break
                        else:
                            epoll_fd.unregister(fd)
                            connections[fd].close()
                            logger.error(msg)
                            break
            elif select.EPOLLHUP &amp; events:
                epoll_fd.unregister(fd)
                connections[fd].close()
                logger.debug("%s ,%d closed" % (addresses[fd][0],addresses[fd][1]))
            elif select.EPOLLOUT &amp; events:
                sendLen=0
                while True:
                    sendLen += connections[fd].send(datalist[fd][sendLen:])
                    if sendLen == len(datalist[fd]):
                         break
                epoll_fd.modify(fd,select.EPOLLIN|select.EPOLLET)
            else:
                continue
</code></pre>

<p><strong><em>common client</em></strong>  commontest.py</p>

<pre><code>import socket
messages = ["This is the message",
         "It will be send",
         "in parts"]

print "Connect to the server"

server_address=("localhost",10001)

#Create a TCP/IP sock
socks=[]
for i in range(10):
     socks.append(socket.socket(socket.AF_INET,socket.SOCK_STREAM))

for s in socks:
    s.connect(server_address)

counter=0
for message in messages:
    for s in socks:
        counter+=1
        print " %s sending %s "%(s.getpeername(),message+" version "+str(counter))
        s.send(message+" version "+str(counter))
    for s in socks:
        data=s.recv(1024)
        print " %s received %s " % (s.getpeername(),data)
        if not data:
            print "closing socket",s.getpeername()
            s.close()
</code></pre>

<p> 针对epoll的使用有一篇很好的博客：scotdoyle.com/python-epoll-howto.html</p>

<p> 针对asyncore的介绍和使用有很好的两篇博客：
 blog.csdn.net/livefun/article/details/8721772</p>

<p> http://www.nightmare.com/medusa/async_sockets.html</p>


  <!-- TODO: bio here -->
  <section class="meta">
    <h3>Discussion, links, and tweets</h3>
    <section class="copy">
      <a href="https://twitter.com/matrixorz" target="_blank">
        <img src="http://www.gravatar.com/avatar/60b5076bc49c5f6157687e39a34ad5cc?s=142" height="50" width="50" />
      </a>

      <p>
        I'm a developer at GitHub. <a href="https://twitter.com/matrixorz" target="_blank">Follow me on Twitter</a>;
        you'll enjoy my tweets. I take care to carefully craft each one. Or at least aim to make
        you giggle. Or offended. One of those two&mdash; I haven't decided which yet.
      </p>

      <a href="http://twitter.com/share" class="twitter-share-button" data-count="none" data-via="matrixorz">Tweet</a>
      <a href="http://twitter.com/matrixorz" class="twitter-follow-button" data-show-count="false">Follow @matrixorz</a>
      <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
    </section>
  </section>
</section>

</body>

</html>
