
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>聚类分析 &mdash; ODPS 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="ODPS 1.0 documentation" href="../../index.html" />
    <link rel="up" title="ODPS XLab/XLib" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="odps_xlib_association.html" title="关联分析"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="odps_xlib_regression.html" title="回归分析"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">ODPS 1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">ODPS XLab/XLib</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="odps-xlib-cluster">
<span id="id1"></span><h1>聚类分析<a class="headerlink" href="#odps-xlib-cluster" title="Permalink to this headline">¶</a></h1>
<p>聚类(Clustering)，简单地说就是把相似的东西分到一组，同分类(Classification)不同，对于一个classifier ，通常需要你告诉它&#8221;这个东西被分为某某类&#8221;这样一些例子，理想情况下，一个classifier会从它得到的训练集中进行&#8221;学习&#8221;，从而具备对未知数据进行分类的能力，这种提供训练数据的过程通常叫做监督学习(supervised learning)，而在聚类的时候，我们并不关心某一类是什么，我们需要实现的目标只是把相似的东西聚到一起，因此，一个聚类算法通常只需要知道如何计算相似度就可以开始工作了，因此clustering通常并不需要使用训练数据进行学习，这在机器学习中被称作无监督学习(unsupervised learning)。</p>
<div class="section" id="kmeans">
<span id="odps-xlib-cluster-kmeans"></span><h2>KMeans<a class="headerlink" href="#kmeans" title="Permalink to this headline">¶</a></h2>
<p>K均值聚类是一种得到最广泛使用的聚类算法，把n个对象分为k个簇，使簇内具有较高的相似度。相似度的计算根据一个簇中对象的平均值来进行。它与处理混合正态分布的最大期望算法很相似，因为他们都试图找到数据中自然聚类的中心。</p>
<p>算法首先随机地选择k个对象，每个对象初始地代表了一个簇的平均值或中心。对剩余的每个对象根据其与各个簇中心的距离，将它赋给最近的簇，然后重新计算每个簇的平均值。这个过程不断重复，直到准则函数收敛。</p>
<p>它假设对象属性来自于空间向量，并且目标是使各个群组内部的均方误差总和最小。KMeans的更多详细介绍请参考 <a class="reference external" href="http://www.cs.cmu.edu/~guestrin/Class/10701-S07/Slides/clustering.pdf">相关文档链接</a></p>
<div class="section" id="id3">
<h3>函数<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>执行help(Cluster.kmeans)可以查看帮助信息</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">kmeans</span><span class="p">(</span>
       <span class="n">inputTableName</span><span class="p">,</span><span class="n">centerCount</span><span class="p">,</span>
       <span class="n">idxTableName</span><span class="p">,</span> <span class="n">centerTableName</span><span class="p">,</span> <span class="n">clusterCountTableName</span><span class="p">,</span>
       <span class="n">selectedColNames</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">selectedPartitions</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
       <span class="n">loop</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">accuracy</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">distanceType</span> <span class="o">=</span> <span class="s">&#39;euclidean&#39;</span><span class="p">,</span>
       <span class="n">initCenterTableName</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">initCentersMethod</span> <span class="o">=</span> <span class="s">&#39;sample&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>参数:</dt>
<dd><ul class="first last simple">
<li>inputTableName：输入表名</li>
<li>centerCount：聚类数</li>
<li>idxTableName：输出聚类编号表，行数等于输入表总行数，每行的值表示输入表对应行表示的点的聚类编号</li>
<li>centerTableName：输出聚类质心表，列数等于输入表(有选中则等于选中列总数)，行数等于聚类数，每行表示一个聚类质心位置</li>
<li>clusterCountTableName：输出聚类点总数表名，行数等于聚类数，每行聚类质心的类中所包含的聚类点的总数</li>
<li>selectedColNames：(可选)输入表选中列，默认为全选，目前只支持double类型</li>
<li>inputPartitions：(可选)输入表选择分区，默认为全选</li>
<li>loop：(可选)计算最大迭代次数 ，默认为100</li>
<li>accuracy：(可选)计算最小迭代精度，默认为0.0</li>
<li>distanceType：(可选)距离测度方法，支持欧式距离(euclidean，默认)，绝度误差和(cityblock)，夹角余弦(cosine)</li>
<li>initCenterTableName：(可选)输入起始center值的表格，当initCentersMethod为matrix时候必须输入</li>
<li>initCentersMethod：(可选)初始质心位置选择方法，支持sample(随机选取，默认)，topk(前K行)，uniform(分布范围均匀随机生成)，matrix(指定表作为初始质心位置)</li>
</ul>
</dd>
</dl>
<p>示例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Cluster</span><span class="o">.</span><span class="n">kmeans</span><span class="p">(</span><span class="s">&quot;kmeans_input&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;idxTable&quot;</span><span class="p">,</span><span class="s">&quot;centerTable&quot;</span><span class="p">,</span><span class="s">&quot;clusterCountTable&quot;</span><span class="p">,</span><span class="n">loop</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li>读取表kmeans_init所有列进行kmeans计算</li>
<li>使用默认的距离计算方法和质心选择方法，当迭代次数到100次时候结束计算</li>
<li>结果存储到idxTable，centerTable，和clusterCountTable三张表中</li>
</ul>
</div>
<div class="section" id="id4">
<h3>界面<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>KMeans界面参数如下图：</p>
<img alt="../../_images/kmeans_para.JPG" src="../../_images/kmeans_para.JPG" />
<p>其中:</p>
<blockquote>
<div><ul class="simple">
<li>最上层为选择输入表的partition；</li>
<li>下方输入表选中列为选择参与KMeans计算的特征列，对应脚本参数selectedColNames，目前只支持double类型的特征列；</li>
<li>初始质心位置选择模块分别对应脚本参数initCentersMethod和initCenterTableName</li>
<li>迭代参数对应脚本loop和accuracy；</li>
<li>计算模块中聚类数对应脚本参数centerCount；</li>
<li>距离计算方式对应脚本参数distanceType；</li>
<li>聚类编号表名，质心表名，个数表名分别对应脚本参数dxTableName, centerTableName, clusterCountTableName；</li>
<li>参数填写完毕后点击确定可以执行。执行结束后界面会一次弹出三张输出表。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id5">
<h3>例子<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>这里我们采用了iris数据集( <a class="reference external" href="http://en.wikipedia.org/wiki/Iris_flower_data_set">Iris flower data set</a> )进行实例，数据如下：</p>
<img alt="../../_images/kmean_example_1_iris.JPG" src="../../_images/kmean_example_1_iris.JPG" />
<p>Iris以鸢尾花的特征作为数据来源，数据集包含150个数据集，分为3类，每类50个数据，每个数据包含4个属性，该数据集数据分布情况如下，可以看到在二维关系下，setosa较为独立，versicolor, virginica中间有部分交杂情况。</p>
<img alt="../../_images/kmean_example_2_iris.JPG" src="../../_images/kmean_example_2_iris.JPG" />
<p>首先在界面上选中k均值聚类：</p>
<img alt="../../_images/kmean_example_3_menu.JPG" src="../../_images/kmean_example_3_menu.JPG" />
<p>显示参数窗口，并按照上文说明填写对应参数：</p>
<img alt="../../_images/kmean_example_4_para.JPG" src="../../_images/kmean_example_4_para.JPG" />
<p>这里我们设置了最大迭代100次，最小精度为0，聚类数为3(由于原表category列为类别，可以对比下我们的聚类结果和原表值)，点击右下角执行开始计算。结果聚类编号表为：</p>
<img alt="../../_images/kmean_example_5_idx.JPG" src="../../_images/kmean_example_5_idx.JPG" />
<p>其中的0,1,2为分类标识</p>
<p>聚类质心表为：</p>
<img alt="../../_images/kmean_example_6_center.JPG" src="../../_images/kmean_example_6_center.JPG" />
<p>每行对应一个分类的质心位置。</p>
<p>聚类个数表为：</p>
<img alt="../../_images/kmean_example_7_count.JPG" src="../../_images/kmean_example_7_count.JPG" />
<p>分别对应每个聚类中的个数。</p>
<p>对于setosa类别，KMeans得到较好的聚类结果，versicolor, virginica两个类别中出现交杂情况，结果符合数据实际情况，提高聚类迭代次数和更好的选择初始点选择可以提升运行结果。 三张数据表在xlab中是有序的，可以通过AppendColumn函数对结果进行贴合。</p>
<dl class="docutils">
<dt>注意事项:</dt>
<dd><ul class="first last simple">
<li>当前KMeans支持最大2000亿(输入表行*列)规模的计算。</li>
</ul>
</dd>
</dl>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">聚类分析</a><ul>
<li><a class="reference internal" href="#kmeans">KMeans</a><ul>
<li><a class="reference internal" href="#id3">函数</a></li>
<li><a class="reference internal" href="#id4">界面</a></li>
<li><a class="reference internal" href="#id5">例子</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="odps_xlib_association.html" title="关联分析"
             >next</a></li>
        <li class="right" >
          <a href="odps_xlib_regression.html" title="回归分析"
             >previous</a> |</li>
        <li><a href="../../index.html">ODPS 1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >ODPS XLab/XLib</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright Alibaba 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  <!-- 请把脚本放到 body 元素内 -->
  </body>
</html>